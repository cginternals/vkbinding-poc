
#pragma once


#include <vkbinding/novk.h>
#include <vkbinding/vk/functions.h>


namespace vk11core
{

// import functions
using vk::vkAllocateCommandBuffers;
using vk::vkAllocateDescriptorSets;
using vk::vkAllocateMemory;
using vk::vkBeginCommandBuffer;
using vk::vkBindBufferMemory;
using vk::vkBindBufferMemory2;
using vk::vkBindImageMemory;
using vk::vkBindImageMemory2;
using vk::vkCmdBeginQuery;
using vk::vkCmdBeginRenderPass;
using vk::vkCmdBindDescriptorSets;
using vk::vkCmdBindIndexBuffer;
using vk::vkCmdBindPipeline;
using vk::vkCmdBindVertexBuffers;
using vk::vkCmdBlitImage;
using vk::vkCmdClearAttachments;
using vk::vkCmdClearColorImage;
using vk::vkCmdClearDepthStencilImage;
using vk::vkCmdCopyBuffer;
using vk::vkCmdCopyBufferToImage;
using vk::vkCmdCopyImage;
using vk::vkCmdCopyImageToBuffer;
using vk::vkCmdCopyQueryPoolResults;
using vk::vkCmdDispatch;
using vk::vkCmdDispatchBase;
using vk::vkCmdDispatchIndirect;
using vk::vkCmdDraw;
using vk::vkCmdDrawIndexed;
using vk::vkCmdDrawIndexedIndirect;
using vk::vkCmdDrawIndirect;
using vk::vkCmdEndQuery;
using vk::vkCmdEndRenderPass;
using vk::vkCmdExecuteCommands;
using vk::vkCmdFillBuffer;
using vk::vkCmdNextSubpass;
using vk::vkCmdPipelineBarrier;
using vk::vkCmdPushConstants;
using vk::vkCmdResetEvent;
using vk::vkCmdResetQueryPool;
using vk::vkCmdResolveImage;
using vk::vkCmdSetBlendConstants;
using vk::vkCmdSetDepthBias;
using vk::vkCmdSetDepthBounds;
using vk::vkCmdSetDeviceMask;
using vk::vkCmdSetEvent;
using vk::vkCmdSetLineWidth;
using vk::vkCmdSetScissor;
using vk::vkCmdSetStencilCompareMask;
using vk::vkCmdSetStencilReference;
using vk::vkCmdSetStencilWriteMask;
using vk::vkCmdSetViewport;
using vk::vkCmdUpdateBuffer;
using vk::vkCmdWaitEvents;
using vk::vkCmdWriteTimestamp;
using vk::vkCreateBuffer;
using vk::vkCreateBufferView;
using vk::vkCreateCommandPool;
using vk::vkCreateComputePipelines;
using vk::vkCreateDescriptorPool;
using vk::vkCreateDescriptorSetLayout;
using vk::vkCreateDescriptorUpdateTemplate;
using vk::vkCreateDevice;
using vk::vkCreateEvent;
using vk::vkCreateFence;
using vk::vkCreateFramebuffer;
using vk::vkCreateGraphicsPipelines;
using vk::vkCreateImage;
using vk::vkCreateImageView;
using vk::vkCreateInstance;
using vk::vkCreatePipelineCache;
using vk::vkCreatePipelineLayout;
using vk::vkCreateQueryPool;
using vk::vkCreateRenderPass;
using vk::vkCreateSampler;
using vk::vkCreateSamplerYcbcrConversion;
using vk::vkCreateSemaphore;
using vk::vkCreateShaderModule;
using vk::vkDestroyBuffer;
using vk::vkDestroyBufferView;
using vk::vkDestroyCommandPool;
using vk::vkDestroyDescriptorPool;
using vk::vkDestroyDescriptorSetLayout;
using vk::vkDestroyDescriptorUpdateTemplate;
using vk::vkDestroyDevice;
using vk::vkDestroyEvent;
using vk::vkDestroyFence;
using vk::vkDestroyFramebuffer;
using vk::vkDestroyImage;
using vk::vkDestroyImageView;
using vk::vkDestroyInstance;
using vk::vkDestroyPipeline;
using vk::vkDestroyPipelineCache;
using vk::vkDestroyPipelineLayout;
using vk::vkDestroyQueryPool;
using vk::vkDestroyRenderPass;
using vk::vkDestroySampler;
using vk::vkDestroySamplerYcbcrConversion;
using vk::vkDestroySemaphore;
using vk::vkDestroyShaderModule;
using vk::vkDeviceWaitIdle;
using vk::vkEndCommandBuffer;
using vk::vkEnumerateDeviceExtensionProperties;
using vk::vkEnumerateDeviceLayerProperties;
using vk::vkEnumerateInstanceExtensionProperties;
using vk::vkEnumerateInstanceLayerProperties;
using vk::vkEnumerateInstanceVersion;
using vk::vkEnumeratePhysicalDeviceGroups;
using vk::vkEnumeratePhysicalDevices;
using vk::vkFlushMappedMemoryRanges;
using vk::vkFreeCommandBuffers;
using vk::vkFreeDescriptorSets;
using vk::vkFreeMemory;
using vk::vkGetBufferMemoryRequirements;
using vk::vkGetBufferMemoryRequirements2;
using vk::vkGetDescriptorSetLayoutSupport;
using vk::vkGetDeviceGroupPeerMemoryFeatures;
using vk::vkGetDeviceMemoryCommitment;
using vk::vkGetDeviceProcAddr;
using vk::vkGetDeviceQueue;
using vk::vkGetDeviceQueue2;
using vk::vkGetEventStatus;
using vk::vkGetFenceStatus;
using vk::vkGetImageMemoryRequirements;
using vk::vkGetImageMemoryRequirements2;
using vk::vkGetImageSparseMemoryRequirements;
using vk::vkGetImageSparseMemoryRequirements2;
using vk::vkGetImageSubresourceLayout;
using vk::vkGetInstanceProcAddr;
using vk::vkGetPhysicalDeviceExternalBufferProperties;
using vk::vkGetPhysicalDeviceExternalFenceProperties;
using vk::vkGetPhysicalDeviceExternalSemaphoreProperties;
using vk::vkGetPhysicalDeviceFeatures;
using vk::vkGetPhysicalDeviceFeatures2;
using vk::vkGetPhysicalDeviceFormatProperties;
using vk::vkGetPhysicalDeviceFormatProperties2;
using vk::vkGetPhysicalDeviceImageFormatProperties;
using vk::vkGetPhysicalDeviceImageFormatProperties2;
using vk::vkGetPhysicalDeviceMemoryProperties;
using vk::vkGetPhysicalDeviceMemoryProperties2;
using vk::vkGetPhysicalDeviceProperties;
using vk::vkGetPhysicalDeviceProperties2;
using vk::vkGetPhysicalDeviceQueueFamilyProperties;
using vk::vkGetPhysicalDeviceQueueFamilyProperties2;
using vk::vkGetPhysicalDeviceSparseImageFormatProperties;
using vk::vkGetPhysicalDeviceSparseImageFormatProperties2;
using vk::vkGetPipelineCacheData;
using vk::vkGetQueryPoolResults;
using vk::vkGetRenderAreaGranularity;
using vk::vkInvalidateMappedMemoryRanges;
using vk::vkMapMemory;
using vk::vkMergePipelineCaches;
using vk::vkQueueBindSparse;
using vk::vkQueueSubmit;
using vk::vkQueueWaitIdle;
using vk::vkResetCommandBuffer;
using vk::vkResetCommandPool;
using vk::vkResetDescriptorPool;
using vk::vkResetEvent;
using vk::vkResetFences;
using vk::vkSetEvent;
using vk::vkTrimCommandPool;
using vk::vkUnmapMemory;
using vk::vkUpdateDescriptorSets;
using vk::vkUpdateDescriptorSetWithTemplate;
using vk::vkWaitForFences;

} // namespace vk11core